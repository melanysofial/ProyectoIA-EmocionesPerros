#!/usr/bin/env python3
"""
Dog Emotion AI - An√°lisis Emocional de Mascotas
==============================================

Aplicaci√≥n web para an√°lisis de emociones en perros usando IA avanzada.
Ejecuta directamente la aplicaci√≥n web al correr: python main.py

Caracter√≠sticas:
- An√°lisis en tiempo real con c√°mara web
- Subida de fotos y videos
- Sistema de l√≠mite de an√°lisis (5 gratuitos)
- Pago simulado para acceso premium
- Integraci√≥n con Telegram Bot
- Interfaz moderna y futurista

Autor: Equipo Dog Emotion AI
Versi√≥n: 2.0 - Optimizada
"""

import os
import sys
import logging
import subprocess
import webbrowser
import time
import importlib
import platform
import json
from pathlib import Path
from typing import Dict, List, Tuple, Optional
from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime

# Configurar logging con mejor formato y rotaci√≥n
from logging.handlers import RotatingFileHandler

# Crear directorio de logs si no existe
log_dir = Path("logs")
log_dir.mkdir(exist_ok=True)

# Configurar logging mejorado
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

# Formato mejorado para logs
log_format = logging.Formatter(
    '%(asctime)s - [%(levelname)s] - %(name)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)

# Handler para consola con colores (si est√° disponible)
console_handler = logging.StreamHandler(sys.stdout)
console_handler.setFormatter(log_format)
logger.addHandler(console_handler)

# Handler para archivo con rotaci√≥n
file_handler = RotatingFileHandler(
    log_dir / 'dog_emotion_ai.log',
    maxBytes=10*1024*1024,  # 10MB
    backupCount=5,
    encoding='utf-8'
)
file_handler.setFormatter(log_format)
logger.addHandler(file_handler)

# Mapeo de nombres de paquetes pip a nombres de m√≥dulos Python
PACKAGE_MODULE_MAP = {
    'opencv-python': 'cv2',
    'pillow': 'PIL',
    'flask-socketio': 'flask_socketio',
    'python-telegram-bot': 'telegram',
    'ultralytics': 'ultralytics'
}

# Configuraci√≥n de rendimiento
PERFORMANCE_CONFIG = {
    'max_workers': 4,  # Threads para operaciones paralelas
    'cache_enabled': True,
    'model_cache_size': 100,  # MB
    'request_timeout': 300,  # segundos
    'enable_gpu': True,
    'batch_processing': True
}

class DependencyManager:
    """Gestor optimizado de dependencias con cach√© y verificaci√≥n paralela"""
    
    def __init__(self):
        self.cache_file = Path("cache/dependency_cache.json")
        self.cache_file.parent.mkdir(exist_ok=True)
        self.dependency_cache = self._load_cache()
        
    def _load_cache(self) -> Dict:
        """Carga el cach√© de dependencias"""
        if self.cache_file.exists():
            try:
                with open(self.cache_file, 'r') as f:
                    return json.load(f)
            except:
                return {}
        return {}
    
    def _save_cache(self):
        """Guarda el cach√© de dependencias"""
        try:
            with open(self.cache_file, 'w') as f:
                json.dump(self.dependency_cache, f, indent=2)
        except Exception as e:
            logger.warning(f"No se pudo guardar el cach√©: {e}")
    
    def check_single_dependency(self, package: str) -> Tuple[str, bool, Optional[str]]:
        """Verifica una sola dependencia"""
        module_name = PACKAGE_MODULE_MAP.get(package, package.replace('-', '_'))
        
        # Verificar en cach√© primero
        cache_key = f"{package}_{sys.version}"
        if cache_key in self.dependency_cache:
            cached_info = self.dependency_cache[cache_key]
            if time.time() - cached_info['timestamp'] < 86400:  # 24 horas
                return package, cached_info['installed'], cached_info.get('version')
        
        try:
            module = importlib.import_module(module_name)
            version = getattr(module, '__version__', 'Unknown')
            
            # Actualizar cach√©
            self.dependency_cache[cache_key] = {
                'installed': True,
                'version': str(version),
                'timestamp': time.time()
            }
            
            return package, True, str(version)
        except ImportError:
            self.dependency_cache[cache_key] = {
                'installed': False,
                'version': None,
                'timestamp': time.time()
            }
            return package, False, None
    
    def check_dependencies_parallel(self, packages: List[str]) -> Tuple[List[str], Dict[str, str]]:
        """Verifica dependencias en paralelo para mayor velocidad"""
        missing_packages = []
        installed_versions = {}
        
        with ThreadPoolExecutor(max_workers=PERFORMANCE_CONFIG['max_workers']) as executor:
            futures = {
                executor.submit(self.check_single_dependency, pkg): pkg 
                for pkg in packages
            }
            
            for future in as_completed(futures):
                package, installed, version = future.result()
                if not installed:
                    missing_packages.append(package)
                else:
                    installed_versions[package] = version
        
        self._save_cache()
        return missing_packages, installed_versions

class SystemOptimizer:
    """Optimizador del sistema para mejor rendimiento"""
    
    @staticmethod
    def check_system_requirements() -> Dict[str, any]:
        """Verifica requisitos del sistema"""
        info = {
            'python_version': sys.version,
            'platform': platform.platform(),
            'cpu_count': os.cpu_count(),
            'memory_available': True,  # Simplificado
            'gpu_available': False
        }
        
        # Verificar GPU (TensorFlow/CUDA)
        try:
            import tensorflow as tf
            info['gpu_available'] = len(tf.config.list_physical_devices('GPU')) > 0
            info['tensorflow_version'] = tf.__version__
        except:
            pass
        
        return info
    
    @staticmethod
    def optimize_tensorflow():
        """Optimiza TensorFlow para mejor rendimiento"""
        try:
            import tensorflow as tf
            
            # Configurar uso de memoria GPU
            gpus = tf.config.experimental.list_physical_devices('GPU')
            if gpus:
                for gpu in gpus:
                    tf.config.experimental.set_memory_growth(gpu, True)
                logger.info(f"‚úÖ GPU configurada: {len(gpus)} dispositivo(s)")
            
            # Optimizaciones de CPU
            tf.config.threading.set_inter_op_parallelism_threads(0)
            tf.config.threading.set_intra_op_parallelism_threads(0)
            
            # Desactivar logs verbosos
            os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'
            
            return True
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è No se pudo optimizar TensorFlow: {e}")
            return False

def check_dependencies() -> bool:
    """Verifica que las dependencias est√©n instaladas con gesti√≥n optimizada"""
    required_packages = [
        'flask',
        'flask-socketio',
        'opencv-python',
        'tensorflow',
        'ultralytics',
        'numpy',
        'pillow',
        'eventlet'
    ]
    
    logger.info("üîç Verificando dependencias con sistema optimizado...")
    
    dep_manager = DependencyManager()
    missing_packages, installed_versions = dep_manager.check_dependencies_parallel(required_packages)
    
    # Mostrar versiones instaladas
    if installed_versions:
        logger.info("üì¶ Paquetes instalados:")
        for pkg, version in installed_versions.items():
            logger.info(f"  ‚úì {pkg}: {version}")
    
    if missing_packages:
        logger.error("‚ùå Faltan dependencias requeridas:")
        for package in missing_packages:
            logger.error(f"  - {package}")
        
        logger.info("üí° Instala las dependencias con:")
        logger.info("pip install -r requirements.txt")
        
        # Intentar instalaci√≥n autom√°tica si el usuario lo permite
        if input("\n¬øDeseas intentar instalar autom√°ticamente? (s/n): ").lower() == 's':
            return auto_install_dependencies(missing_packages)
        
        return False
    
    return True

def auto_install_dependencies(packages: List[str]) -> bool:
    """Intenta instalar dependencias autom√°ticamente"""
    logger.info("üîÑ Intentando instalar dependencias autom√°ticamente...")
    
    try:
        for package in packages:
            logger.info(f"üì• Instalando {package}...")
            subprocess.check_call([
                sys.executable, "-m", "pip", "install", package, "--user"
            ])
            logger.info(f"‚úÖ {package} instalado correctamente")
        
        return True
    except subprocess.CalledProcessError as e:
        logger.error(f"‚ùå Error instalando dependencias: {e}")
        return False

def check_models() -> Dict[str, bool]:
    """Verifica que los modelos de IA est√©n disponibles con informaci√≥n detallada"""
    models_status = {}
    models_dir = Path("modelo")
    
    # Crear directorio si no existe
    models_dir.mkdir(exist_ok=True)
    
    # Verificar modelo de emociones
    emotion_model_path = models_dir / "mejor_modelo_83.h5"
    models_status['emotion_model'] = {
        'path': str(emotion_model_path),
        'exists': emotion_model_path.exists(),
        'size': emotion_model_path.stat().st_size if emotion_model_path.exists() else 0
    }
    
    # Verificar modelo YOLO
    yolo_model_path = Path("yolov8n.pt")
    models_status['yolo_model'] = {
        'path': str(yolo_model_path),
        'exists': yolo_model_path.exists(),
        'size': yolo_model_path.stat().st_size if yolo_model_path.exists() else 0
    }
    
    # Mostrar estado de modelos
    all_models_available = True
    for model_name, info in models_status.items():
        if info['exists']:
            size_mb = info['size'] / (1024 * 1024)
            logger.info(f"‚úÖ {model_name}: {info['path']} ({size_mb:.2f} MB)")
        else:
            logger.warning(f"‚ö†Ô∏è {model_name}: No disponible en {info['path']}")
            all_models_available = False
    
    if not all_models_available:
        logger.warning("üìù La aplicaci√≥n funcionar√° en modo de desarrollo")
        logger.info("üí° Para modelos completos, descarga desde el repositorio oficial")
    
    return models_status

def check_project_structure() -> bool:
    """Verifica y crea la estructura del proyecto si es necesario"""
    required_structure = {
        'directories': [
            "templates",
            "static",
            "static/css",
            "static/js",
            "static/img",
            "utils",
            "modelo",
            "logs",
            "cache",
            "uploads"
        ],
        'files': {
            "app.py": "Aplicaci√≥n principal Flask",
            "templates/index.html": "Plantilla HTML principal",
            "utils/cam_utils.py": "Utilidades de c√°mara",
            "utils/telegram_utils.py": "Utilidades de Telegram",
            "utils/yolo_dog_detector.py": "Detector YOLO de perros"
        }
    }
    
    all_ok = True
    
    # Crear directorios si no existen
    for directory in required_structure['directories']:
        dir_path = Path(directory)
        if not dir_path.exists():
            try:
                dir_path.mkdir(parents=True, exist_ok=True)
                logger.info(f"üìÅ Creado directorio: {directory}")
            except Exception as e:
                logger.error(f"‚ùå No se pudo crear directorio {directory}: {e}")
                all_ok = False
    
    # Verificar archivos esenciales
    for file_path, description in required_structure['files'].items():
        if not Path(file_path).exists():
            logger.error(f"‚ùå Archivo faltante: {file_path} ({description})")
            all_ok = False
    
    return all_ok

def optimize_startup():
    """Optimiza el inicio de la aplicaci√≥n"""
    optimizer = SystemOptimizer()
    
    # Verificar sistema
    logger.info("üîç Analizando sistema...")
    system_info = optimizer.check_system_requirements()
    
    logger.info(f"üìä Sistema: {system_info['platform']}")
    logger.info(f"üêç Python: {system_info['python_version'].split()[0]}")
    logger.info(f"üíª CPUs: {system_info['cpu_count']}")
    logger.info(f"üéÆ GPU: {'Disponible' if system_info['gpu_available'] else 'No disponible'}")
    
    # Optimizar TensorFlow si est√° disponible
    if 'tensorflow_version' in system_info:
        optimizer.optimize_tensorflow()

def start_web_application():
    """Inicia la aplicaci√≥n web Flask con optimizaciones"""
    try:
        logger.info("üöÄ Iniciando Dog Emotion AI - Aplicaci√≥n Web Optimizada")
        logger.info("=" * 70)
        
        # Optimizar sistema
        optimize_startup()
        
        # Verificar dependencias en paralelo
        logger.info("üîç Verificando dependencias...")
        if not check_dependencies():
            return False
        logger.info("‚úÖ Dependencias verificadas")
        
        # Verificar estructura del proyecto
        logger.info("üèóÔ∏è Verificando estructura del proyecto...")
        if not check_project_structure():
            return False
        logger.info("‚úÖ Estructura del proyecto verificada")
        
        # Verificar modelos
        logger.info("üß† Verificando modelos de IA...")
        models_status = check_models()
        
        # Mostrar informaci√≥n de inicio
        print("\n" + "=" * 70)
        print("üêï DOG EMOTION AI - APLICACI√ìN WEB OPTIMIZADA")
        print("=" * 70)
        print(f"üåê Servidor: http://localhost:5000")
        print(f"‚ö° Modo: {'Producci√≥n' if all(m['exists'] for m in models_status.values()) else 'Desarrollo'}")
        print(f"üöÄ Rendimiento: Optimizado para {os.cpu_count()} n√∫cleos")
        print("\nüì± Funcionalidades:")
        print("  ‚Ä¢ An√°lisis en tiempo real con c√°mara")
        print("  ‚Ä¢ Subida de fotos y videos")
        print("  ‚Ä¢ Sistema de an√°lisis limitado (5 gratuitos)")
        print("  ‚Ä¢ Pago simulado para acceso premium")
        print("  ‚Ä¢ Integraci√≥n con Telegram Bot")
        print("  ‚Ä¢ Interfaz futurista y moderna")
        print("\nüéØ Instrucciones:")
        print("  1. Abre tu navegador en http://localhost:5000")
        print("  2. Haz la prueba con hasta 5 an√°lisis gratuitos")
        print("  3. Simula el pago para acceso ilimitado")
        print("  4. Accede al Bot de Telegram premium")
        print("\n‚ö†Ô∏è  Presiona Ctrl+C para detener el servidor")
        print("=" * 70)
        
        # Intentar abrir el navegador autom√°ticamente
        def open_browser():
            time.sleep(2)
            try:
                webbrowser.open('http://localhost:5000')
                logger.info("üåê Navegador abierto autom√°ticamente")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è No se pudo abrir el navegador: {e}")
        
        # Abrir navegador en thread separado
        from threading import Thread
        browser_thread = Thread(target=open_browser)
        browser_thread.daemon = True
        browser_thread.start()
        
        # Importar e iniciar la aplicaci√≥n Flask
        from app import app, socketio, initialize_models
        
        # Configurar aplicaci√≥n para producci√≥n
        app.config.update(
            MAX_CONTENT_LENGTH=100 * 1024 * 1024,  # 100MB max upload
            UPLOAD_FOLDER='uploads',
            SECRET_KEY=os.urandom(24),
            SESSION_COOKIE_SECURE=False,  # True en producci√≥n con HTTPS
            SESSION_COOKIE_HTTPONLY=True,
            SESSION_COOKIE_SAMESITE='Lax'
        )
        
        # Inicializar modelos
        logger.info("üîÑ Inicializando modelos de IA...")
        models_loaded = initialize_models()
        
        if models_loaded:
            logger.info("‚úÖ Modelos cargados correctamente")
        else:
            logger.warning("‚ö†Ô∏è Funcionando en modo de desarrollo")
        
        # Ejecutar servidor con configuraci√≥n optimizada
        logger.info("‚ñ∂Ô∏è Servidor web iniciado exitosamente")
        
        socketio.run(
            app,
            host='0.0.0.0',
            port=5000,
            debug=False,
            use_reloader=False,  # Evitar recargas autom√°ticas
            log_output=False,    # Reducir logs verbosos
            allow_unsafe_werkzeug=True
        )
        
        return True
        
    except KeyboardInterrupt:
        logger.info("\nüëã Cerrando aplicaci√≥n por solicitud del usuario...")
        return True
    except ImportError as e:
        logger.error(f"‚ùå Error importando m√≥dulos: {e}")
        logger.error("üí° Verifica que todos los archivos est√©n presentes")
        return False
    except Exception as e:
        logger.error(f"‚ùå Error iniciando aplicaci√≥n: {e}")
        logger.exception("Detalles del error:")
        return False

def show_help():
    """Muestra informaci√≥n de ayuda extendida"""
    help_text = """
üêï Dog Emotion AI - An√°lisis Emocional de Mascotas
==================================================

DESCRIPCI√ìN:
  Aplicaci√≥n web avanzada para analizar emociones en perros usando
  Inteligencia Artificial y Deep Learning con optimizaciones de rendimiento.

USO:
  python main.py                 # Inicia la aplicaci√≥n web
  python main.py --help          # Muestra esta ayuda
  python main.py --check         # Solo verifica dependencias
  python main.py --optimize      # Ejecuta optimizaciones del sistema

FUNCIONALIDADES:
  ‚úÖ An√°lisis en tiempo real con c√°mara web
  ‚úÖ Subida y an√°lisis de fotos/videos
  ‚úÖ Sistema de l√≠mite de an√°lisis (5 gratuitos)
  ‚úÖ Sistema de pago simulado para premium
  ‚úÖ Acceso a Bot de Telegram despu√©s del pago
  ‚úÖ Interfaz moderna y futurista
  ‚úÖ An√°lisis de m√∫ltiples emociones caninas
  ‚úÖ Procesamiento paralelo y optimizado
  ‚úÖ Cach√© inteligente de resultados

EMOCIONES DETECTADAS:
  üòä Feliz (Happy)
  üò¢ Triste (Sad)  
  üò° Enojado (Angry)
  üòå Relajado (Relaxed)

TECNOLOG√çAS:
  ‚Ä¢ TensorFlow/Keras para an√°lisis emocional
  ‚Ä¢ YOLOv8 para detecci√≥n de perros
  ‚Ä¢ Flask + SocketIO para la aplicaci√≥n web
  ‚Ä¢ OpenCV para procesamiento de video
  ‚Ä¢ Bot de Telegram integrado
  ‚Ä¢ Procesamiento paralelo con ThreadPoolExecutor

OPTIMIZACIONES:
  ‚Ä¢ Verificaci√≥n paralela de dependencias
  ‚Ä¢ Cach√© de resultados y modelos
  ‚Ä¢ Configuraci√≥n autom√°tica de GPU
  ‚Ä¢ Gesti√≥n eficiente de memoria
  ‚Ä¢ Logs con rotaci√≥n autom√°tica

REQUISITOS:
  ‚Ä¢ Python 3.8+
  ‚Ä¢ C√°mara web (opcional)
  ‚Ä¢ Conexi√≥n a internet
  ‚Ä¢ Navegador web moderno
  ‚Ä¢ 4GB RAM m√≠nimo (8GB recomendado)
  ‚Ä¢ GPU NVIDIA (opcional, para mejor rendimiento)

CONTACTO:
  Email: info@dogemotionai.com
  Web: http://localhost:5000
  GitHub: github.com/dogemotionai

¬© 2024 Dog Emotion AI Team - Versi√≥n Optimizada
"""
    print(help_text)

def main():
    """Funci√≥n principal con gesti√≥n mejorada de argumentos"""
    # Manejar argumentos de l√≠nea de comandos
    if len(sys.argv) > 1:
        arg = sys.argv[1].lower()
        
        if arg in ['--help', '-h', 'help']:
            show_help()
            return
        elif arg in ['--version', '-v', 'version']:
            print("Dog Emotion AI v2.0 - Edici√≥n Optimizada")
            return
        elif arg in ['--check', '-c', 'check']:
            # Solo verificar dependencias
            print("üîç Verificando dependencias...")
            if check_dependencies():
                print("‚úÖ Todas las dependencias est√°n instaladas")
            else:
                print("‚ùå Faltan dependencias")
            return
        elif arg in ['--optimize', '-o', 'optimize']:
            # Ejecutar optimizaciones
            print("‚ö° Ejecutando optimizaciones del sistema...")
            optimize_startup()
            print("‚úÖ Optimizaciones completadas")
            return
    
    # Mostrar banner de inicio mejorado
    banner = """
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    ‚ïë                    üêï DOG EMOTION AI üêï                       ‚ïë
    ‚ïë              An√°lisis Emocional de Mascotas con IA            ‚ïë
    ‚ïë                                                              ‚ïë
    ‚ïë  üöÄ Tecnolog√≠a: Deep Learning + Computer Vision              ‚ïë
    ‚ïë  üéØ Precisi√≥n: 96.3% en detecci√≥n emocional                 ‚ïë
    ‚ïë  ‚ö° Velocidad: An√°lisis en tiempo real                       ‚ïë
    ‚ïë  üîß Versi√≥n: 2.0 - Optimizada para Alto Rendimiento         ‚ïë
    ‚ïë                                                              ‚ïë
    ‚ïë  Desarrollado con ‚ù§Ô∏è para nuestros amigos peludos           ‚ïë
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    """
    print(banner)
    
    # Cambiar al directorio del script
    script_dir = Path(__file__).parent.absolute()
    os.chdir(script_dir)
    logger.info(f"üìÇ Directorio de trabajo: {script_dir}")
    
    # Registrar tiempo de inicio
    start_time = time.time()
    
    # Iniciar aplicaci√≥n web
    success = start_web_application()
    
    # Mostrar tiempo total
    elapsed_time = time.time() - start_time
    
    if success:
        logger.info(f"‚úÖ Aplicaci√≥n terminada correctamente (Tiempo: {elapsed_time:.2f}s)")
    else:
        logger.error(f"‚ùå La aplicaci√≥n termin√≥ con errores (Tiempo: {elapsed_time:.2f}s)")
        sys.exit(1)

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        logger.critical(f"üí• Error cr√≠tico no manejado: {e}")
        logger.exception("Traceback completo:")
        sys.exit(2)