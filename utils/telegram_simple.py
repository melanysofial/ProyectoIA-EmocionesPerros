"""
Sistema de Telegram simplificado y corregido
=========================================

Esta versi√≥n usa requests directamente para evitar problemas con asyncio
y garantizar compatibilidad completa con la aplicaci√≥n web.
"""

import requests
import logging
import time
import os
from datetime import datetime
from typing import Optional, Dict, Any

logger = logging.getLogger(__name__)

class SimpleTelegramBot:
    """Bot de Telegram simplificado usando requests directamente"""
    
    def __init__(self, token: str = None, chat_id: str = None):
        self.token = token or os.getenv('TELEGRAM_BOT_TOKEN', '7565394500:AAEqYMlT4mQFGTlL8slsSrlrst3MZmeMzIg')
        self.chat_id = chat_id or os.getenv('TELEGRAM_CHAT_ID', '1846987938')
        self.base_url = f"https://api.telegram.org/bot{self.token}"
        
        # Estado del monitoreo
        self.monitoring_active = True
        self.emotion_history = []
        self.last_status_time = 0
        
        # Validar token y chat_id
        if not self.token or self.token == 'YOUR_BOT_TOKEN':
            raise ValueError("‚ùå Token de Telegram no v√°lido")
        if not self.chat_id or self.chat_id == 'YOUR_CHAT_ID':
            raise ValueError("‚ùå Chat ID no v√°lido")
        
        logger.info(f"ü§ñ Bot inicializado - Chat ID: {self.chat_id}")
        
        # Recomendaciones por emoci√≥n
        self.recommendations = {
            'angry': [
                "üö® Tu perro parece molesto. Aqu√≠ algunas recomendaciones:",
                "‚Ä¢ Revisa si hay ruidos fuertes que lo estresen",
                "‚Ä¢ Verifica que tenga agua fresca y comida",
                "‚Ä¢ Dale un espacio tranquilo para calmarse",
                "‚Ä¢ Evita forzar interacciones hasta que se calme",
                "‚Ä¢ Si persiste, consulta con un veterinario"
            ],
            'sad': [
                "üò¢ Tu perro se ve triste. Te sugerimos:",
                "‚Ä¢ Ded√≠cale tiempo de calidad y caricias",
                "‚Ä¢ S√°calo a pasear si es posible",
                "‚Ä¢ Revisa si est√° enfermo o tiene dolor",
                "‚Ä¢ Aseg√∫rate de que no est√© solo por mucho tiempo",
                "‚Ä¢ Considera juguetes interactivos para estimularlo",
                "‚Ä¢ Si la tristeza persiste, consulta al veterinario"
            ],
            'happy': [
                "üòä ¬°Tu perro est√° feliz! Esto es genial:",
                "‚Ä¢ Contin√∫a con las actividades que lo hacen feliz",
                "‚Ä¢ Es un buen momento para entrenamientos positivos",
                "‚Ä¢ Puedes introducir nuevos juegos o juguetes"
            ],
            'relaxed': [
                "üòå Tu perro est√° relajado:",
                "‚Ä¢ Es el estado ideal, contin√∫a as√≠",
                "‚Ä¢ Mant√©n el ambiente tranquilo",
                "‚Ä¢ Es buen momento para descanso"
            ]
        }
    
    def _make_request(self, method: str, data: Dict[Any, Any] = None, files: Dict[str, Any] = None, timeout: int = 15) -> Optional[Dict]:
        """Hacer request a la API de Telegram"""
        try:
            url = f"{self.base_url}/{method}"
            
            if files:
                response = requests.post(url, data=data, files=files, timeout=timeout)
            else:
                response = requests.post(url, json=data, timeout=timeout)
            
            if response.status_code == 200:
                result = response.json()
                if result.get('ok'):
                    return result
                else:
                    logger.error(f"‚ùå API Error: {result}")
                    return None
            else:
                logger.error(f"‚ùå HTTP Error {response.status_code}: {response.text}")
                return None
                
        except requests.exceptions.Timeout:
            logger.error("‚ùå Timeout en request a Telegram")
            return None
        except requests.exceptions.ConnectionError:
            logger.error("‚ùå Error de conexi√≥n a Telegram")
            return None
        except Exception as e:
            logger.error(f"‚ùå Error en request: {e}")
            return None
    
    def test_connection(self) -> bool:
        """Probar conexi√≥n con Telegram"""
        try:
            logger.info("üß™ Probando conexi√≥n con Telegram...")
            
            # Test 1: Verificar bot
            result = self._make_request('getMe', timeout=10)
            if not result:
                logger.error("‚ùå No se pudo verificar el bot")
                return False
            
            bot_info = result['result']
            logger.info(f"ü§ñ Bot verificado: @{bot_info.get('username', 'N/A')} ({bot_info.get('first_name', 'N/A')})")
            
            # Test 2: Enviar mensaje de prueba
            test_message = "üß™ **Test de Conexi√≥n**\n\nSi recibes este mensaje, Telegram funciona correctamente.\n\n‚úÖ Conexi√≥n establecida exitosamente"
            
            result = self.send_message(test_message)
            if result:
                logger.info("‚úÖ Test de conexi√≥n exitoso")
                return True
            else:
                logger.error("‚ùå Fall√≥ el env√≠o de mensaje de prueba")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Error en test de conexi√≥n: {e}")
            return False
    
    def send_simple_message(self, message: str) -> bool:
        """Alias para send_message para compatibilidad"""
        return self.send_message(message)
    
    def send_message(self, message: str, parse_mode: str = 'Markdown') -> bool:
        """Enviar mensaje de texto"""
        try:
            data = {
                'chat_id': self.chat_id,
                'text': message,
                'parse_mode': parse_mode
            }
            
            result = self._make_request('sendMessage', data)
            if result:
                message_id = result['result']['message_id']
                logger.info(f"‚úÖ Mensaje enviado - ID: {message_id}")
                return True
            else:
                logger.error("‚ùå Error enviando mensaje")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Error enviando mensaje: {e}")
            return False
    
    def send_photo(self, photo_path: str, caption: str = "") -> bool:
        """Enviar foto con caption"""
        try:
            if not os.path.exists(photo_path):
                logger.error(f"‚ùå Imagen no encontrada: {photo_path}")
                return False
            
            data = {
                'chat_id': self.chat_id,
                'caption': caption,
                'parse_mode': 'Markdown'
            }
            
            with open(photo_path, 'rb') as photo_file:
                files = {'photo': photo_file}
                result = self._make_request('sendPhoto', data, files)
            
            if result:
                message_id = result['result']['message_id']
                logger.info(f"‚úÖ Foto enviada - ID: {message_id}")
                return True
            else:
                logger.error("‚ùå Error enviando foto")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Error enviando foto: {e}")
            return False
    
    def send_alert(self, emotion: str, probability: float, image_path: str = None) -> bool:
        """Enviar alerta de emoci√≥n"""
        try:
            if not self.monitoring_active:
                logger.info("‚ö†Ô∏è Monitoreo pausado - Alerta no enviada")
                return False
            
            logger.info(f"üö® Enviando alerta: {emotion} ({probability:.2f})")
            
            # Obtener recomendaciones
            recommendations = self.recommendations.get(emotion, ["‚Ä¢ Observa el comportamiento de tu mascota"])
            
            # Crear mensaje
            message = f"üêï **ALERTA DE COMPORTAMIENTO**\n\n"
            message += f"Emoci√≥n detectada: **{emotion.upper()}** ({probability:.2f})\n"
            message += f"Detectado en el an√°lisis actual.\n\n"
            message += "\n".join(recommendations)
            message += f"\n\nüìä Confianza: {probability*100:.1f}%"
            message += f"\n‚è∞ Hora: {datetime.now().strftime('%H:%M:%S')}"
            
            # Enviar con imagen si est√° disponible
            if image_path and os.path.exists(image_path):
                success = self.send_photo(image_path, message)
                if success:
                    logger.info("‚úÖ Alerta con imagen enviada")
                    return True
                else:
                    logger.warning("‚ö†Ô∏è Fall√≥ env√≠o con imagen, enviando solo texto")
            
            # Enviar solo texto
            success = self.send_message(message)
            if success:
                logger.info("‚úÖ Alerta enviada")
                return True
            else:
                logger.error("‚ùå Error enviando alerta")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Error enviando alerta: {e}")
            return False
    
    def send_video_summary(self, video_stats: Dict[str, Any]) -> bool:
        """Enviar resumen COMPLETO de an√°lisis de video con gr√°ficos y video procesado"""
        try:
            if not self.monitoring_active:
                logger.info("‚ö†Ô∏è Monitoreo pausado - Resumen no enviado")
                return False
            
            logger.info("üìπ Enviando resumen completo de video...")
            
            stats = video_stats
            emotion_dist = stats.get('emotion_distribution', {})
            dominant = stats.get('dominant_emotion', 'unknown')
            confidence = stats.get('confidence_avg', 0)
            video_path = stats.get('video_path', '')
            
            # PARTE 1: Resumen con video procesado
            if video_path and os.path.exists(video_path):
                logger.info("üì§ Enviando video procesado...")
                video_caption = (
                    f"üé¨ **AN√ÅLISIS DE VIDEO COMPLETADO**\n\n"
                    f"‚úÖ An√°lisis de emociones completado\n"
                    f"üêï Detecciones YOLO superpuestas\n"
                    f"üìä Resumen detallado a continuaci√≥n"
                )
                
                # Enviar video procesado
                if self.send_video(video_path, video_caption):
                    logger.info("‚úÖ Video procesado enviado")
                else:
                    logger.warning("‚ö†Ô∏è No se pudo enviar video, continuando con resumen")
            
            # PARTE 2: Resumen estad√≠stico DETALLADO
            message = f"üìä **AN√ÅLISIS DE VIDEO COMPLETADO**\n\n"
            
            # Informaci√≥n del archivo
            message += f"üìÅ **Video:**\n"
            message += f"{stats.get('video_name', 'video.mp4')}\n"
            message += f"üéØ Detecciones totales: {stats.get('total_emotions', 0)}\n\n"
            
            # Emoci√≥n dominante destacada
            emotion_emoji = {'happy': 'üòä', 'sad': 'üò¢', 'angry': 'üò†', 'relaxed': 'üòå'}
            dominant_emoji = emotion_emoji.get(dominant, 'üêï')
            message += f"üéØ **Emoci√≥n dominante: {dominant.upper()}** {dominant_emoji}\n\n"
            
            # Distribuci√≥n con barras visuales
            message += "üìä **Distribuci√≥n:**\n"
            for emotion, count in emotion_dist.items():
                if count > 0:
                    percentage = (count / stats.get('total_emotions', 1)) * 100
                    emoji = emotion_emoji.get(emotion, '‚Ä¢')
                    # Crear barra visual simple
                    bar_length = int(percentage / 10)  # M√°ximo 10 caracteres
                    bar = '‚ñà' * bar_length + '‚ñë' * (10 - bar_length)
                    message += f"{emoji} **{emotion.upper()}:** {count} ({percentage:.1f}%) {bar}\n"
            
            # Estad√≠sticas t√©cnicas
            message += f"\nüìà **Estad√≠sticas:**\n"
            message += f"üìä Confianza promedio: {confidence*100:.1f}%\n"
            message += f"üé• Frames procesados: {stats.get('total_frames', 'N/A')}\n"
            message += f"üêï Detecci√≥n de perros: {stats.get('detection_rate', 'N/A')}\n"
            message += f"‚ö° Velocidad: {stats.get('fps', 'N/A')} FPS\n"
            
            # Recomendaciones basadas en resultados
            message += f"\nüí° **Recomendaci√≥n:**\n"
            if dominant == 'happy':
                message += "Perfecto estado de alegr√≠a. üòä\n‚Ä¢ Contin√∫a con las actividades que lo hacen feliz\n‚Ä¢ Tu perro est√° en su zona de comfort"
            elif dominant == 'relaxed':
                message += "Perfecto estado de relajaci√≥n. üòå\n‚Ä¢ Mant√©n el ambiente tranquilo\n‚Ä¢ Tu perro est√° en su zona de comfort"
            elif dominant == 'sad':
                message += "Se detect√≥ tristeza. üò¢\n‚Ä¢ Ded√≠cale m√°s tiempo y atenci√≥n\n‚Ä¢ Verifica si tiene alguna molestia\n‚Ä¢ Considera actividades estimulantes"
            elif dominant == 'angry':
                message += "Se detect√≥ agitaci√≥n. üò†\n‚Ä¢ Identifica fuentes de estr√©s\n‚Ä¢ Proporciona un espacio tranquilo\n‚Ä¢ Evita est√≠mulos molestos"
            
            # Informaci√≥n final
            message += f"\nüì± **Video procesado guardado:**\n"
            message += f"{stats.get('processed_filename', 'video_procesado.mp4')}\n\n"
            message += f"‚è∞ **An√°lisis completado:** {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}"
            
            # Enviar resumen completo
            success = self.send_message(message)
            if success:
                logger.info("‚úÖ Resumen completo de video enviado")
                return True
            else:
                logger.error("‚ùå Error enviando resumen completo")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Error enviando resumen: {e}")
            return False
    
    def send_video(self, video_path: str, caption: str = "") -> bool:
        """Enviar video con caption"""
        try:
            if not os.path.exists(video_path):
                logger.error(f"‚ùå Video no encontrado: {video_path}")
                return False
            
            # Verificar tama√±o del archivo (Telegram tiene l√≠mite de 50MB)
            file_size = os.path.getsize(video_path)
            if file_size > 50 * 1024 * 1024:  # 50MB
                logger.warning(f"‚ö†Ô∏è Video muy grande ({file_size / (1024*1024):.1f}MB), enviando solo resumen")
                return False
            
            data = {
                'chat_id': self.chat_id,
                'caption': caption,
                'parse_mode': 'Markdown'
            }
            
            with open(video_path, 'rb') as video_file:
                files = {'video': video_file}
                result = self._make_request('sendVideo', data, files, timeout=60)  # Timeout m√°s largo para videos
            
            if result:
                message_id = result['result']['message_id']
                logger.info(f"‚úÖ Video enviado - ID: {message_id}")
                return True
            else:
                logger.error("‚ùå Error enviando video")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Error enviando video: {e}")
            return False
    
    def send_welcome_message(self) -> bool:
        """Enviar mensaje de bienvenida"""
        try:
            message = (
                "üêï **DOG EMOTION AI - SISTEMA ACTIVADO**\n\n"
                "¬°Hola! Tu sistema de monitoreo emocional para mascotas est√° ahora activo.\n\n"
                "**Funcionalidades disponibles:**\n"
                "‚Ä¢ üîî Alertas autom√°ticas de comportamiento\n"
                "‚Ä¢ üìä Res√∫menes de an√°lisis en tiempo real\n"
                "‚Ä¢ üìπ An√°lisis completo de videos\n"
                "‚Ä¢ üí° Recomendaciones personalizadas\n\n"
                "**Estado actual:**\n"
                f"üîî Monitoreo: {'‚úÖ ACTIVO' if self.monitoring_active else '‚ùå PAUSADO'}\n"
                f"‚è∞ Iniciado: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
                "¬°Comenzar√© a enviarte actualizaciones sobre el estado emocional de tu mascota!"
            )
            
            return self.send_message(message)
            
        except Exception as e:
            logger.error(f"‚ùå Error enviando mensaje de bienvenida: {e}")
            return False
    
    def update_emotion_history(self, emotion: str):
        """Actualizar historial de emociones"""
        try:
            self.emotion_history.append({
                'emotion': emotion,
                'timestamp': time.time()
            })
            
            # Mantener solo los √∫ltimos 100 registros
            if len(self.emotion_history) > 100:
                self.emotion_history = self.emotion_history[-100:]
                
        except Exception as e:
            logger.error(f"‚ùå Error actualizando historial: {e}")
    
    def send_periodic_update(self):
        """Enviar actualizaci√≥n peri√≥dica"""
        try:
            current_time = time.time()
            
            # Solo enviar si han pasado al menos 30 minutos
            if current_time - self.last_status_time > 1800:  # 30 minutos
                if self.emotion_history and self.monitoring_active:
                    
                    # Calcular estad√≠sticas recientes
                    recent_emotions = [e for e in self.emotion_history if current_time - e['timestamp'] < 3600]  # √öltima hora
                    
                    if recent_emotions:
                        emotion_counts = {}
                        for entry in recent_emotions:
                            emotion = entry['emotion']
                            emotion_counts[emotion] = emotion_counts.get(emotion, 0) + 1
                        
                        dominant = max(emotion_counts.items(), key=lambda x: x[1])
                        
                        message = (
                            "üïê **ACTUALIZACI√ìN PERI√ìDICA**\n\n"
                            f"Estado general en la √∫ltima hora:\n"
                            f"üéØ Emoci√≥n predominante: **{dominant[0].upper()}**\n"
                            f"üìä Total de an√°lisis: {len(recent_emotions)}\n"
                            f"‚è∞ Hora: {datetime.now().strftime('%H:%M:%S')}\n\n"
                            "El sistema contin√∫a monitoreando a tu mascota."
                        )
                        
                        self.send_message(message)
                        self.last_status_time = current_time
                        
        except Exception as e:
            logger.error(f"‚ùå Error en actualizaci√≥n peri√≥dica: {e}")
    
    def clear_chat_sync(self):
        """Limpiar historial del chat - placeholder para compatibilidad"""
        try:
            logger.info("üßπ Limpiando historial de chat...")
            # En esta versi√≥n simplificada solo enviamos mensaje informativo
            self.send_message(
                "üßπ **HISTORIAL LIMPIADO**\n\n"
                "El historial de an√°lisis ha sido reiniciado.\n"
                f"‚è∞ {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
            )
            logger.info("‚úÖ Historial limpiado")
            return True
        except Exception as e:
            logger.error(f"‚ùå Error limpiando historial: {e}")
            return False
    
    def cleanup(self):
        """Limpiar recursos"""
        try:
            logger.info("üßπ Limpiando bot de Telegram...")
            # En esta versi√≥n simplificada no hay recursos espec√≠ficos que limpiar
            logger.info("‚úÖ Bot limpiado")
        except Exception as e:
            logger.error(f"‚ùå Error limpiando bot: {e}")


# Funci√≥n de conveniencia para mantener compatibilidad
TelegramBot = SimpleTelegramBot


if __name__ == "__main__":
    """Test r√°pido del bot"""
    
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - [%(levelname)s] - %(message)s'
    )
    
    try:
        # Crear bot
        bot = SimpleTelegramBot()
        
        # Test de conexi√≥n
        print("üß™ Probando conexi√≥n...")
        if bot.test_connection():
            print("‚úÖ Conexi√≥n exitosa")
            
            # Test de alerta
            print("üß™ Probando alerta...")
            bot.send_alert('happy', 0.95)
            
            print("‚úÖ Todas las pruebas exitosas")
        else:
            print("‚ùå Fallo en la conexi√≥n")
            
    except Exception as e:
        print(f"‚ùå Error en test: {e}")